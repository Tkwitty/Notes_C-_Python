[TOC]

# 算法

- 一般面试笔试的时间是两个小时  完成3到5个算法题的编程：

```
算法思想：动态规划、递归、回溯、分治、贪心
```

```
二分查找、冒泡排序、快速排序、堆排序（4套源码）
二叉树的遍历【前序（深度优先）、中序、后续、层次（广度优先）】=》【递归式、非递归式】（8套源码）
```

## 回溯法：

矩阵是否存在字符串路径





## 排序：

堆排序，如果使用递归方式实现则空间复杂度为 O(logN)

#### 数组合并+排序

·把两个有序数组合并为一个数组，第一个数组空间正好可以容纳两个数组的元素？
	最大比较，大者拷贝至最后，倒序依次比较ab所有数直到结束，

#### 有重复原地快排

·只包含0,1,2的有重复整数数组进行排序，原地排序（交换）？
	**快排**划分方法，时间On，空间O1

![1560916045525](./_pics_\1560916045525.png)

![1560916163699](./_pics_\1560916163699.png)

#### 有序矩阵查找

·在行列都排好序的矩阵中找数？找k时若有返回true，若没有返回false

![1560925440400](./_pics_\1560925440400.png)

​	时间Om+n，空间O1。从最左上角点开始，大时排除下方，小时排除左方，直到找到或者遍历结束

![1560925583694](./_pics_\1560925583694.png)

#### 最短需排序子组

·需要排序的“连续”最短子数组长度？【1，5，4，3，2，6，7】因为只有【5，4，3，2】要排序，故返回4

​	时间On，空间O1。

![1560949716789](./_pics_\1560949716789.png)

![1560949869966](./_pics_\1560949869966.png)

#### 最大相邻差值

·给定一个整型数组arr，返回如果排序后相邻两数的最大差值？例如某有序数组1234789，最大差值来自47，返回3

​	时间On，空间On。**桶排序**思想

![1560950420133](./_pics_\1560950420133.png)



## 字符串：

​	1.广泛性：字符串可以看做字符类型的数组与数组排序、查找、调整有关；其它类型面试题可以看做字符串类型的面试题。注意：Java实现字符串类题目时，需要用StringBuffer，StringBuilder类和toCharArray方法。

​	2.需掌握的概念：回文；子串（连续）；子序列（不连续）；前缀树（Trie树）；后缀树 / 后缀数组；匹配；字典序

​	3.需掌握的操作：增删改查；字符的替换；字符串的旋转；

​	4.常见题目类型：

​		**规则判断**：1.判断字符串是否符合**整数规则**；2.是否符合**浮点数规则**；3.是否符合**回文字符串规则**；...
​		**数字运算**：int 和 long 类型表达整数范围有限，常用字符串表示大整数，模拟相关大数**加减乘除**操作；
​		**数组操作**：数组有关的调整、排序；如掌握和改写快速排序的划分过程；
​		**字符计数**：1.哈希表；2.固定长度的数组（C256,java65536）；3.滑动窗口问题、寻找无重复字符子串问题；
​		**动态规划**：1.最长公共子串；2.最长公共子序列；3.最长回文子串；
​		**搜索类型**：宽度有限搜索；深度优先搜索；
​		**高级算法与数据结构**：（面试很少出现）
​			1.Manacher算法·最长回文子串问题；
​			2.KMP算法·字符串匹配；
​			3.前缀树，后缀树/数组；
​			4.线段树；

#### 两树有无同构子树

·给定独立的两棵树头结点分别为t1（n大）、t2（m小），判断t1中是否有与t2树（拓扑）结构相同的子树？
	普通解法：也是暴力匹配法，依次以每个节点为头结点进行匹配，知道t1被遍历完毕 Onxm
	最优解法：二叉树序列化 + KMP算法 On+m
		二叉树t1序列化为str1，t2序列化为str2，用kmp算法查找n长的str1中是否包含m长的str2

#### 是否互为变形词

·给定str1和str2，如果str1与str2中字符种类与其次数都一样，称str1与str2互为变形词，用函数判断是否互为变形词？
	可以用**固长数组**替代**哈希表**结构，时间On，空间On

![1560953338803](./_pics_\1560953338803.png)

#### 是否互为旋转词

·字符串str，把字符串前面任意部分挪到后面形成的字符串叫做str的旋转词。
	比如str=“1234”，str的旋转词有“1234”，“2341”，“3412”，“4123”，用函数判断是否互为旋转词？
	解法：1.判断str1与str2是否长度相等；2.若长度相等，生成str1+str1的大字符串；3.用kmp算法判断大字符串中是否含有str2。

#### 单词逆调

·给定一个字符串str，请在单词间做逆序调整。例如“pig loves dog”逆序为“dog loves pig”
	1.实现让字符串逆序的函数f；2.利用f将整个字符串逆序；3.找到2得到的每个单词区域，利用f将每个单词区域逆序

#### 左右对调

·给定一个字符串str 和一个整数i。i代表str中的位置，将 str[0..i]移到右侧，str[i+1..N-1]移到左侧。
	比如str=“ABCDE”，i=2。将str调整为“DEABC”。要求时间On，空间O1。

![1560957384469](./_pics_\1560957384469.png)

#### 字典最小拼接顺序

·给定一个字符串数组strs，找一种拼接顺序使所有字符串拼接起来组成大字符串是所有可能性中字典顺序最小的，并返回这个大字符串。例如strs=[’abc‘，’de‘]   返回’abcde‘，strs=[’b‘，’ba‘]   返回’bab‘。
	最优解时间Onlogn，排序实现
	方案：如果str1+str2 < str2+str1，则str1放在前面，否则str2放在前面。

#### 空格替换

·给定一个字符串str，将所有空格字符替换成%20，假设长度足够长。 例如“a b c”

![1560999092127](./_pics_\1560999092127.png)

#### 括号是否合法

·给定一个含括号的字符串str，判断是不是整体有效的括号字符串。例如“(()())”"(())"为true，"())""()a()"为false

![1560999405662](./_pics_\1560999405662.png)

#### 最长无重子串

·给定一个字符串str，返回str的最长无重复字符子串长度。str=‘abcd’返回4，str=‘abcb’返回3。
	时间On，空间On，求出以str中每个字符串结尾的情况下，最长无重复字符子串的长度，并在其中找出最大值返回

![1561001767285](./_pics_\1561001767285.png)

![1561001995751](./_pics_\1561001995751.png)



## 栈和队列：

​	1.栈是先进后出的。
​	2.队列是先进。
​	3.栈和队列在实现结构上可以有数组和链表两种形式。
​		·数组结构实现较容易；
​		·用链表结构较复杂，因为牵扯很多指针操作
​	4.栈和队列的基本操作都是时间复杂度 O1 

**栈结构的基本操作:**

​	1.pop操作
​	2.top或peek操作
​	3.push操作
​	4.size操作
​	**递归函数** 实际上用到函数栈，递归过程可看做递归函数依次进入函数栈的过程，所有递归函数都可以非递归实现

**队列的基本操作：**

​	push操作为在队头加入元素；
​	pop操作是从队为弹出一个元素；

​	**双端队列**：首部尾部 都可以压入和弹出元素
​	**优先级队列**：根据元素的优先级值，决定弹出顺序。（为堆结构而非线性结构）

![1561014006287](./_pics_\1561014006287.png)

![1561014153377](./_pics_\1561014153377.png)

#### 返回栈最小值

·实现一个特殊的栈，在实现栈的基本功能的基础上，在实现返回栈中最小元素的操作 getmin。
	要求：pop，push，getmin操作的时间O1，设计栈可以使用现成的栈结构。

![1561015054760](./_pics_\1561015054760.png)

![1561015223456](./_pics_\1561015223456.png)

#### 两栈队列

·编写一个类，只能用两个栈结构实现队列，支持队列的基本操作（add，poll，peek）

![1561015991297](./_pics_\1561015991297.png)

![1561016042158](./_pics_\1561016042158.png)

​	也就是说，倒数据的前提：出栈必须为空，入栈中的数据要一次性倒完

#### 栈序逆转

·实现一个栈的逆序，但是只能用递归函数和这个栈本身的操作来实现，不能自己申请另外的数据结构

![1561018714189](./_pics_\1561018714189.png)

![1561018909784](./_pics_\1561018909784.png)

![1561019020000](./_pics_\1561019020000.png)

![1561019371711](./_pics_\1561019371711.png)

#### 栈的排序

·一个栈中元素为整型，现在想将该栈从顶到底按从大到小**排序**，只许申请一个栈和新的变量，不能申请额外的数据结构

![1561020150937](./_pics_\1561020150937.png)

#### 数组最值滤波

·有一个整型数组 arr 和 一个大小为 w 的窗口从数组的最左边滑到最右边，窗口每次向右边划一个位置。
	返回一个长度为n-w+1的数组 res，res[i]表示每一种窗口状态下的最大值。例如[43543367]，返回[555467]
	普通解法的时间On*w：选取每一次窗口遍历w个数的最大值；
	最优解法的时间On：

![1561037000073](./_pics_\1561037000073.png)

![1561037389801](./_pics_\1561037389801.png)

#### 数组生成大根树

·给定一个没有重复元素的数组arr，写出生成这个数组的 MaxTree 的函数。要求如果数组长度为 N，时间On，空间On
	MaxTree：一颗二叉树，数组每个值对应一个节点；包括MT数在内的每个子树上最大值都是树的根节点。

![1561037949685](./_pics_\1561037949685.png)

![1561038367520](./_pics_\1561038367520.png)

![1561038526919](./_pics_\1561038526919.png)



## 链表：

1.链表问题算法难度不高，但考察代码实现能力。
2.链表和数组都是一种线性结构：
	数组是一段连续的存储空间；链表空间不一定保证连续，为临时分配的；
3.链表的分类：
	按方向：单链表，双链表
	按有无环：普通链表，循环链表

![1561039173127](./_pics_\1561039173127.png)

![1561039246215](./_pics_\1561039246215.png)

#### 单链表翻转

·单链表翻转操作：（最终返回当前的 head 节点 now）

![1561039622680](./_pics_\1561039622680.png)

1.大量链表问题可使用额外数据结构来简化调整
2.但链表问题最优解往往是不使用额外数据结构的方法

#### 有序单环链表插入

·给定一个整数num，如何在节点值有序的环形链表中插入一个节点值为num的节点，并且保证这个环形单链表依然有序。

![1561040862506](./_pics_\1561040862506.png)

#### node节点删除

·给定一个链表中的节点node，但不给定整个链表的头结点。如何在链表中删除node？要求时间复杂度为O1。

![1561041271767](./_pics_\1561041271767.png)

#### 链表的有序划分

·给定一个链表头结点head，一个数num，请把链表调整为节点值小于num的节点都放在链表的左边，只等于num的节点都放在链表的中间，值大于num的节点，都放在链表的右边。
	普通解法：将链表所有节点放在数组中，进行快排划分调整。

![1561041881868](./_pics_\1561041881868.png)

#### 有序链表所有相等节点

·给定两个有序链表的头结点head1和head2，打印两个有序链表的公共部分。
	若两个链表任何一个为空，不可能有公共部分，直接返回即可。
	若两个链表都不为空：

![1561042225330](./_pics_\1561042225330.png)

#### 链表的K-逆转

·给定一个单链表的头结点head，调整单链表使得每K个节点之间逆序，如果最后不够K个节点则不调整。

![1561042648834](./_pics_\1561042648834.png)

![1561042791722](./_pics_\1561042791722.png)

![1561042953716](./_pics_\1561042953716.png)

![1561042992061](./_pics_\1561042992061.png)

#### 删除指定值节点

·给定一个单链表头结点head。链表中每个节点保存一个整数，给定一个值val，把所有等于val的节点删掉。

![1561043366462](./_pics_\1561043366462.png)

#### 链表的回文判断

·判断一个链表是否为回文结构。例如：链表1->2->3->2->1，是回文结构，返回true，1->2->3->1返回false。

![1561044020818](./_pics_\1561044020818.png)

![1561044503757](./_pics_\1561044503757.png)

![1561044741535](./_pics_\1561044741535.png)

#### 随机指针链表的复制

·一个链表中每个节点不仅含有next指针，同时含有一条可能指向任何一个的节点rand指针，请复制这种链表。

![1561045234245](./_pics_\1561045234245.png)

#### 链表有无环

·如何判断一个单链表是否有环？有环则返回进入环的第一个节点，无环则返回空。要求时间On，空间O1。
	普通解法：哈希表实现，从头结点开始遍历在哈希表中记录节点，若有重复则有环，无重复则无环。

![1561046002914](./_pics_\1561046002914.png)

#### 两单链表是否相交

·如何判断两个无环单链表是否相交？相交的话返回第一个相交的节点，不想交的话返回空。
	如果两个链表长度为n，m，请做到时间On+m，空间O1。
	普通解法：哈希表实现，遍历第一个链表，将所有节点记录到哈希表中，再遍历第二个链表，一旦遇到哈希表中有记录存在，则返回；若遍历结束没有遇到则返回空。

![1561046338056](./_pics_\1561046338056.png)

#### 两单环链表是否相交

·如何判断两个有环单链表相交？相交的话返回第一个相交节点，不想交的话返回空。
	如果两个链表长度为n，m，请做到时间On+m，空间O1。

![1561046546317](./_pics_\1561046546317.png)

![1561046745256](./_pics_\1561046745256.png)



·给定两个单链表的头结点head1和head2，如何判断两个单链表是否相交？相交则返回第一个相交节点，不相交则返回空

![1561046877220](./_pics_\1561046877220.png)



## 二分搜索：

应用场景：1.在有序序列中查找一个数，时间OlogN；2.并不一定非要序列有序！
常见考点：对于边界条件的考察及代码实现能力；
考点变化：1.给定对象不同：无重复序列，有重复序列；2.判断条件不同:...；3.返回内容不同：...；
有序循环数组的二分搜索
二分公式：
	常规写法  mid = (left + right)/2   可能溢出
	安全写法  mid = left + (right - left)/2

#### 任意局部最小

·给定一个无序数组arr，已知任意相邻元素都不重复，返回**任意**一个局部最小的位置。【同时小于左右】
	二分搜索，时间Ologn

![1561194482480](./_pics_\1561194482480.png)

#### 有序数组最左位

·给定一个有序数组arr，一个整数num，请在arr中找到num这个数出现的最左边的位置。

![1561194813401](./_pics_\1561194813401.png)

#### 有序环数组最小值

·给定一个有序循环数组arr，返回arr中的最小值。
	有序（>=）循环数组是指，最多只允许一个位置是逆序（<），如12334，41233都是有序循环数组。

![1561195836616](./_pics_\1561195836616.png)

#### 有序数组最左值标相等位

·给定一个有序数组arr，不含重复元素，请找到满足arr[i]==i条件的最左的位置。如果数都不满足返回-1。

![1561196287433](./_pics_\1561196287433.png)

#### 完全二叉树节点数

·给定一个完全二叉树的头结点head，返回这颗树的节点数。若树的节点数为N，要求时间<On。

![1561196968480](./_pics_\1561196968480.png)

![1561197027573](./_pics_\1561197027573.png)

#### 求k的n次方

·如何更快的求一个整数K的N次方。两数相乘为时间O1，要求以Ologn实现k的n方。

![1561197661576](./_pics_\1561197661576.png)



## 二叉树：

![1561197851384](./_pics_\1561197851384.png)

![1561197938489](./_pics_\1561197938489.png)

递归、非递归（栈实现）方式实现 先中后序遍历，其中后续遍历的实现方式较多较复杂。
无论是递归法还是非递归法，遍历整棵树都是时间On，空间OL。【n为节点数，L为树深】

#### 二叉树遍历

深优：先、中、**后**

广优：层

时间On，空间OL:【n为节点数，L为树深】

![1562678512955](./_pics_\1562678512955.png)

![1562679029567](./_pics_\1562679029567.png)

#### 按层打印二叉树

·二叉树按层遍历，针对二叉树的宽度优先遍历，常使用队列结构，面试题常要求打印行号。

![1561199147689](./_pics_\1561199147689.png)

**二叉树的序列化和反序列化**

1.先序遍历序列化；2.中序遍历序列化；3.后序遍历序列化；4.按层序列化。
序列化：二叉树被记录为文件的过程；反序列化：通过文件内容重建为二叉树的过程。



#### 重建二叉树

(深优：)先，中，后，（广优:）层：已知两种序列建成完整结构



#### 二叉树序列化与反序列化

·给定二叉树头结点head，节点值32位整形，设计其序列化和反序列化方案？
	设（先序）序列化结果为str，初始为 空字符串
	遍历二叉树：遇到空节点，末尾添加 “#!”；遇到非空节点x，末尾添加 “x!” 【需要用！表示节点的结束避免歧义】
·str = "12!3!#!#!#!" 的反序列化：
	按照“！”分割为字符数组（节点组）values=["12","3","#","#","#"]，同样用**先序遍历**方式进行二叉树的创建
序列化结果唯一，唯一的结果反序列化生成的二叉树唯一
按层遍历序列化，队列方式实现。

**二叉树子树 & 平衡二叉树**

![1561199763128](./_pics_\1561199763128.png)

#### 二叉树是否平衡-

·给定一颗二叉树的头结点head，判断一棵树是否是平衡二叉树。【递归实现】
	判断当前节点的左子树和右子树是否分别是平衡二叉树，如果是判断左右子树的**深度差值是否<=1**。

![1561200126048](./_pics_\1561200126048.png)

**·搜索二叉树**

![1561200248602](./_pics_\1561200248602.png)

#### 二叉树是否搜索-

·给定一棵二叉树头结点head，判断这棵树是否为搜索二叉树。

![1561200362133](./_pics_\1561200362133.png)

**满二叉树**

![1561200432741](./_pics_\1561200432741.png)

**完全二叉树**

![1561200569420](./_pics_\1561200569420.png)

#### 二叉树是否完全-

·给定一颗二叉树头结点head，判断一棵树是否为完全二叉树。

![1561200706813](./_pics_\1561200706813.png)



关于二叉树的面试：

![1561200891035](./_pics_\1561200891035.png)

![1561201148581](./_pics_\1561201148581.png)

![1561200979341](./_pics_\1561200979341.png)

#### 返回任意节点后继

·只给定二叉树中的某个节点node，该节点并不一定是头结点，实现返回node的后继节点的函数。

![1561201275045](./_pics_\1561201275045.png)

![1561201629333](./_pics_\1561201629333.png)

#### 纸条N次折痕方向

·把一段纸条竖着放在桌子上，从下向上对折一次压出折痕，此时折痕下凹。如果下向上对折两次将压出三条折痕...
	给定一个输入参数N，代表纸条从下向上对折N次，请从上到下打印所有折痕方向。

![1561201877463](./_pics_\1561201877463.png)

#### 搜索二叉树的换位节点

·一棵二叉树原本是搜索二叉树，但是其中有两个节点调换了位置，找到这两个错误节点。

![1561205767372](./_pics_\1561205767372.png)

#### 所有节点间沿途距离

·从二叉树节点出发，可上可下但沿途点只可经过一次，路径节点A到B的距离为沿途节点数量。

![1561205994138](./_pics_\1561205994138.png)

​	给定一棵二叉树头结点head，求整棵树上节点间最大距离。

![1561206109650](./_pics_\1561206109650.png)

![1561206307387](./_pics_\1561206307387.png)

#### 找最大子搜索树

·给定一棵二叉树头结点head，已知所有节点值都不一样，找到含有节点最多的 搜索二叉树并返回其子树根。

![1561206487571](./_pics_\1561206487571.png)

![1561206549829](./_pics_\1561206549829.png)

![1561206646957](./_pics_\1561206646957.png)



## 算术运算 与 位运算：

![1561206776066](./_pics_\1561206776066.png)

#### 亿级存在查找

·网页黑名单包含 100亿 个url，每个url最多64字节。实现一个网页过滤系统，可根据url判断该网页是否在黑名单上。
	要求系统只允许万分之一的误判率，使用的额外空间<=30G。

![1561207315993](./_pics_\1561207315993.png)

![1561207452076](./_pics_\1561207452076.png)

### 布隆过滤器：

![1561207793989](./_pics_\1561207793989.png)

![1561208162717](./_pics_\1561208162717.png)

![1561208213907](./_pics_\1561208213907.png)

#### 空间O的数值交换

·如何不用任何额外变量 交换 两个整数的值？

![1561208656484](./_pics_\1561208656484.png)

#### 无比判大小

·给定两个32位整数a和b，返回a和b中较大的而不用比较来判断。

![1561209664048](./_pics_\1561209664048.png)

![1561209922736](./_pics_\1561209922736.png)

#### 数组唯一奇次数

·给定一个整形数组arr，其中只有一个数出现了奇数次，打印这个数。（其余都出现偶数次）
	要求时间On，空间O1。

![1561210362352](./_pics_\1561210362352.png)

#### 数组唯二奇次数

·给定一个整型数组arr，其中有两个数出现了奇数次，打印这个数。（其余都出现偶数次）
	要求时间On，空间O1.

![1561210671652](./_pics_\1561210671652.png)

#### 异或加密法

·请设置一种加密过程，完成对明文text的加密和解密工作。

![1561210812505](./_pics_\1561210812505.png)



## 排列组合：

![1561212511785](./_pics_\1561212511785.png)

·在6x9的方格中，左上角起点，右下角终点，每次只能向下或者向右，一共有多少种走法？

![1561212695175](./_pics_\1561212695175.png)

·ABCDEFG七人站队，要求A必须在B的左边，但不要求一定相邻，请问共有多少种排法？
	如果要求A必须在B相邻的左边，一共有多少种排法？

![1561213050335](./_pics_\1561213050335.png)

·六个人排一排，要求甲与乙不相邻，并且甲与丙不相邻的排法数是多少？

![1561213408144](./_pics_\1561213408144.png)

·10颗相同的糖果，分给3个人，每人至少一颗，问有多少中分法？

![1561213744350](./_pics_\1561213744350.png)

·10个不同的求放入3个不同的桶里有多少种方法？

![1561213877175](./_pics_\1561213877175.png)

·有10颗糖，每天至少吃一颗吃完为止，有多少种吃法？ 

![1561214076135](./_pics_\1561214076135.png)

·假设有N对左右括号，求出合法排列有多少个？合法是指每一个括号都可以找到与之配对的括号【案例七：**卡特兰数**】

![1561214884147](./_pics_\1561214884147.png)

·N个数进出栈的顺序有多少种？假设栈的容量无限大。

![1561215290689](./_pics_\1561215290689.png)

·2N个人排队买票，N个人拿5块钱，N个人拿10块钱，票价5元一张，每人买一张票，售票员手里没有零钱，问有多少种派对方法让售票员可以顺利卖票。

![1561215314172](./_pics_\1561215314172.png)

·求N个无差别节点构成的二叉树有多少种不同的结构？  

![1561215705849](./_pics_\1561215705849.png)

·12个高矮不同的人排成两排，每排必须从矮到高排列，而且第二排比对应的第一排人高，问排列方式有多少种？

![1561215874728](./_pics_\1561215874728.png)

·N个信封含N封信，现在把信拿出来再装回去，要求每封信不能装回它原来的信封，有多少种装法？

![1561216011415](./_pics_\1561216011415.png)



## 概率：

![1561288907792](./_pics_\1561288907792.png)

![1561288976195](./_pics_\1561288976195.png)

·有8只球队，3个强队，其余都是弱队，随机把它们分成4组比赛，每组两个队， 两强相遇的概率是多大？

![1561289551807](./_pics_\1561289551807.png)

·三只蚂蚁从正三角形的三个顶点沿着边移动，速度相同，它们碰头概率是多少？

![1561289739132](./_pics_\1561289739132.png)

·假设某地重男轻女，一个家庭生女孩就一直生，直到生男停止。假设一胎一孩，时间足够长后男女比例是多少？ 

![1561290174461](./_pics_\1561290174461.png)

·给定一个等概论随机产生1~5的随机函数，不能使用任何额外的随机机制，请实现等概率随机产生1~7的随机函数？

![1561290492758](./_pics_\1561290492758.png)

·给定一个以p概率产生0，以1-p概率产生1的随机概率函数 f()，p是固定的值，但你并不知道是多少。除此之外也不能使用任何额外的随机机制，请用 f() 实现等概率随机产生0和1的随机函数。

![1561290843411](./_pics_\1561290843411.png)

·假设函数 f 等概率随机返回一个在 [0,1) 范围上的浮点数，那么在 [0,x) 区间上的数出现的概率为 x（0<x<=1）。
	给定一个大于0的整数k，并且可以使用 f 函数，请实现一个函数依然返回在 [0,1) 范围上的数，但是在 [0,1) 区间上的数出现的概率为 x的k次方。

![1561291408628](./_pics_\1561291408628.png)

·给定一个长度为 N 且没有重复元素的数组 arr 和一个整数 M，实现函数等概率随机打印 arr 中的 M 个数。

![1561292994370](./_pics_\1561292994370.png)

·一个机器按自然数序列的方式吐球，1号球，2号球，...。有一个最多可装K个球的袋子，一个球一旦扔掉不可拿回。
	设计一种选择方式，当机器吐出第N号球时，袋子中的球数为K，同时保证1-N号球每一个被选进袋的概率为 K/N。

![1561293383000](./_pics_\1561293383000.png)

![1561293450705](./_pics_\1561293450705.png)

![1561293812841](./_pics_\1561293812841.png)



## 大数据：

Map-Reduce 和 Hadoop 逐渐成为面试热门

**哈希函数：**

![1561294011034](./_pics_\1561294011034.png)

![1561294096685](./_pics_\1561294096685.png)

Map-Reduce：

![1561294311834](./_pics_\1561294311834.png)

#### 统计文章所有词频

·用map-reduce方法统计一篇文章中每个单词出现的个数？

![1561300477241](./_pics_\1561300477241.png)

·常见海量数据处理题目关键？

![1561300651175](./_pics_\1561300651175.png)

#### 亿级ip排序

·请对10亿个IPV4的ip地址进行排序，每个ip只会出现一次。

![1561300873361](./_pics_\1561300873361.png)

#### 亿级年龄排序

·请对10亿人的年龄进行排序。

![1561301176126](./_pics_\1561301176126.png)

#### 亿级最众数

·一个包含20亿个全是32位整数的大文件，在其中找到出现次数最多的数。但是内存限制只有2G。

![1561302788464](./_pics_\1561302788464.png)

#### 任意未出现的数

·32位无符号整数范围：0~4294967295（42亿）。现在有一个正好包含40亿个无符号整数的文件，整个范围中必然有没出现过的数
	只用找到一个没出现过的数即可，最多可使用10M内存，该如何找？

![1561303359887](./_pics_\1561303359887.png)

![1561303451230](./_pics_\1561303451230.png)

#### 亿级top-K

·某搜索公司一天的用户搜索词汇是海量的，假设有百亿的数据量，请设计一种求出每天最热100词的可行办法。

![1561304122455](./_pics_\1561304122455.png)

·工程师常使用集群来设计和实现数据缓存，以下是常见的策略：
	1.无论是添加、查询还是删除数据，都先将数据的id通过哈希函数转换成哈希值，记为key；
	2.如果目前机器有N台，则计算key%N的值，这个值就是该数据所属机器编号，添加/删除/查询都在这台机器进行；
请分析这种缓存策略可能带来的问题，并提出改进的方案。

![1561304454766](./_pics_\1561304454766.png)

![1561304641501](./_pics_\1561304641501.png)

![1561304835271](./_pics_\1561304835271.png)



## 动态规划：

#### 面值货币兑钱法

·给定数组arr，arr中所有的值都为正数且不重复。每个值代表一种面值货币，每种面值货币可以使用任意张，再给定一个整数aim代表要找的钱数，求换钱有多少种方法。

![1561305464681](./_pics_\1561305464681.png)

![1561379060455](./_pics_\1561379060455.png)

![1561379619572](./_pics_\1561379619572.png)

![1561380017629](./_pics_\1561380017629.png)

![1561380106335](./_pics_\1561380106335.png)

![1561380478554](./_pics_\1561380478554.png)

![1561380656111](./_pics_\1561380656111.png)

![1561380806625](./_pics_\1561380806625.png)

#### 一步两步上台阶

·有N级台阶，一个人每次上一级或者两极，问有多少种走完n级台阶的方法？

​	实际上是 **斐波那契数列** 问题：递归法，循环法，矩阵法。

​	要注意斐波那契数列的**变换问题**！

![1561381006766](./_pics_\1561381006766.png)

#### 矩阵最小路径和

·给定一个矩阵m，从左上角开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有的数字累加起来就是路径和，返回所有的路径中最小的路径和。

![1561381463358](./_pics_\1561381463358.png)

![1561381586533](./_pics_\1561381586533.png)

#### 最长递增子序列

·给定数组arr，返回arr的最长递增子序列长度。
	比如 arr=[2,1,5,3,6,4,8,9,7]，最长递增子序列为[1,3,4,8,9]，所以返回这个子序列的长度5。

![1561382072985](./_pics_\1561382072985.png)

#### 最长公共子序列

·给定两个字符串str1和str2，返回两个字符串的**最长公共子序列**。
	例如，str1=“1A2C3D4B56”，str2=“B1D2CA45B6A”，“123456”或者“12C4B6”都是最长公共子序列，返回哪个都行。

![1561382443869](./_pics_\1561382443869.png)

#### 最大价值兑换法

·一个背包有一定的承重W，有N件物品，每件都有自己的价值，记录在数组v中，也都有自己的重量，记录在数组w中，没见物品只能选择要装入背包还是不装入背包，要求在不超过背包承重的前提下，选出物品的总价值最大。

![1561382807136](./_pics_\1561382807136.png)

#### 最小代价转换

·给定两个字符串 str1和str2，再给定三个整数ic、dc和rc，分别代表插入、删除和替换一个字符的代价。返回将str1编辑成str2的最小代价。
	比如，str1=“abc”，str2=“adc”，ic=5，dc=3，rc=2。从“abc”编辑成“adc”，把“b”替换成“d”是代价最小的，所以返回2
	再比如，str1=“abc”，str2=“adc”，ic=5，dc=3，rc=100。从“abc”编辑成“adc”，先删b再插d是代价最小的，返回8

![1561383639960](./_pics_\1561383639960.png)

![1561383897206](./_pics_\1561383897206.png)








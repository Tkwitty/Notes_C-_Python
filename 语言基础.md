**算法·语言基础**（c++36题 + py23题 + 常问）

[TOC]



#### -------------------C++-----------------

#### 1.C、C++区别、C++11新特性？

|             C              |                 C++                  |
| :------------------------: | :----------------------------------: |
|          C89标准           | C++99标准（C的超集，拥有类似的语法） |
|    结构化语言，面向过程    |    + 面向对象（封装、继承、多态）    |
| 动态内存分配：malloc，free |      动态内存分配：new，delete       |
|          有struct          |          有struct，有class           |

​	**C++**：（增加了）输入输出；变量的初始化与常量；引用；特殊函数（析构、虚函、内联、友元...）；命名空间；（函数，操作符）重载；模板...

​	**C++11新特性**：nullptr 空指针；auto, decltype 类型获取；lambda表达式（匿名函数）；迭代for循环；std新增容器（array、forward_list、tuple）；正则表达式；移动构造函数move......

#### 2.cpp编译环境？

​	C++编译环境由五部分构成：C++标准库、C语言兼容库、编译器扩展库、编译模块（c++标准语法、拓展语法）

![1564061190989](.\pics2\1564061190989.png)

#### 3.C++是类型安全的吗？

​	不是，不同类型的指针之间可以（用reinterpret cast）进行 <u>强制类型转换</u>

#### 4.main 函数执行 前/后 发生了什么？

​	调用main函数之前：初始化栈、堆，打开标准输入、输出、错误流，把参数压栈，一些【全局变量、对象和静态变量、对象】的空间分配和初始化。
​	调用main函数之后：销毁堆内存，关闭标准输入，输出，错误流。

#### 5.引用、指针的区别？

​	(1)定义指针时**分配内存**，引用否；
​	(2)在定义引用时必须**初始化**，指针否；
​	(3)不存在**指向空值**的引用，指针否。

​	引用：作为函数参数（函数会直接改变实参的值）、作为函数返回值（定义在函数名前，好处是在内存中不产生返回值的副本）、常引用（所引用的对象不会被改变）？

#### 6.智能指针？

​	实质是一个对象，行为表现像一个指针；自动释放内存；
​		**shared_ptr** 允许多个指针指向同一对象；
​		**unique_ptr** 独占所指向的对象；
​		**weak_ptr** 一种弱引用，指向shared_ptr所指向的对象。

#### 7.指针数组、数组指针的区别？

​	**数组指针**，指向数组的指针；
​	**指针数组**，元素均为指针的数组。

#### 8.函数参数 值传递、地址传递、引用传递区别？

​	(1) **值传递**，将实参拷贝一个副本作为形参，函数不会直接改变实参的值
​	(2) **引用传递**，形参作为实参的别名，函数会直接改变实参的值
​	(3) **指针（地址）传递**，将实参的指针变量（地址）作为形参，函数会直接改变实参的值

#### 9.int fun()、int fun(void)的区别?

​	C中，int fun() 输入类型和个数没有限制；int fun(void) 输入类型必须为void。
​	C++中，两种都被解释为输入void类型。

#### 10.全局变量、局部变量的区别？

​	1.生命周期：全局变量随主程序，局部变量只在函数或循环体等内部存在；
​	2.使用方式：声明全局变量后程序的各个部分都可以用到；局部变量只能在局部内使用； 

​	操作系统·编译器可通过**内存分配位置**区分变量类型，全局变量分配在**全局数据段**并且在程序开始运行的时候被加载，局部变量分配在**堆栈** 。

#### 11.链表、数组的区别？

​	(1) （链表和数组）都是线性表
​		**数组**在内存中开辟**一段物理连续的空间**来存储数据；
​		**链表**是利用指针形成**一片逻辑连续的空间**来存储数据；
​	(2) 数组要求空间连续，占用总空间小；链表不要求空间连续，占用总空间大；
​	(3) 数组排序查找快，但删除插入慢；链表删除插入快，但查找排序慢。

#### 12.结构（结构体）、联合（公共体）

​	都是由多个不同的数据类型成员组成；区别：1.联合中所有成员共用一块地址空间（联合只**存放一个成员**），结构中不同成员的存放地址不同（结构**存放所有成员**）。 2.对联合成员赋值，原来的值会被重写（不存在了）；对结构成员赋值互不影响。

#### 13.函数模板、函数重载的区别？

​	1.函数重载，函数名相同，参数列表不同（参数个数&类型）；
​	2.模板函数，几个函数的具体算法相同，处理的参数类型不同；
​	3.模板函数可减少重载函数，但容易出bug。

#### 14.重写、重载、重定义区别？

​	1.重载：同一个类中的函数，名字相同而参数列表不同；
​	2.重写(覆盖)：位于基类和派生类，函数名与参数列表都相同，**virtual关键字**（相当于抽象方法）
​	3.重定义(隐藏)：派生类函数屏蔽了基类同名函数：
​		a.函数名相同，参数列表不同，无论有无virtual关键字基类函数都被隐藏；
​		b.函数名相同，参数列表相同，没有virtual关键字时基类函数被隐藏，有时不隐藏。

#### 15.运算符重载？

​	不能重载的五个运算符：(1) .	(2) ?:	(3) sizeof	(4) ::	(5) *
​	i++、++i的区别？++运算符的重载？

#### 16.static关键字作用？

​	1.函数体内static变量的作用域为该函数体，内存只分配一次，下次调用时维持上次的值；（auto变量呢？）
​	2.模块内static变量只能被模块内的函数访问，不能被模块外部函数访问；
​	3.模块内static函数只能被模块内的函数调用，不能被模块外部函数调用；
​	4.类内static成员变量属于整个类，对类的对象只有一份拷贝（？）；
​	5.类内static成员函数属于整个类，只能访问类内static成员变量。

#### 17.const关键字作用？

​	1.const 关键字定义的变量一旦被初始化将不会被改变。
​	2.函数声明中，const修饰形参，表示在函数内部不能改变其值；
​	3.类声明中，const修饰成员函数（常函数），表示该函数不能修改类内的成员变量；
​	4.类内成员函数，有时必须指定const返回值类型，使返回值不为左值（？）。

=》**函数名后面接const修饰符？**
	加在（类内成员）函数的后面表示this的类型是const，表示函数不能修改this指向的对象（不能修改成员变量）

=》数据成员能否既是const又是static，为什么？
	1.可以，这种数据表示为静态常量；
	2.const（常量）一般在构造函数后初始化；
	3.static（静态成员）一般在类外初始化；
	4.静态常量在类外初始化，同时要声明为const。

#### 18.const与#define比较？

​	const作用：定义常量、修饰函数参数、修饰函数返回值。被Const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。

​	**const常量**有数据类型，编译器可以对前者进行类型安全检查。
​	**宏常量**没有数据类型，只进行字符替换，没有类型安全检查，不安全。

#### 19.malloc / free、new / delete的区别？

​	1.malloc与free是C++/C语言的标准库**函数**，new/delete是C++的**运算符**，都可以申请动态内存和释放内存；
​	2.C++对象在创建时要执行<u>构造函数</u>，消亡时要执行<u>析构函数</u>，maloc/free无法处理动态对象，而且malloc/free是库函数而不是运算符，编译器没有控制权限，不能强加<u>执行构造函数和析构函数</u>的任务。new/delete 运算符可完成动态内存分配和对象初始化，以及清理对象与释放内存的工作。

#### 20.delete、delete [] 的区别？

​	delete只会调用一次析构函数，而delete[]会调用每一个数组成员的析构函数；
​	delete与new配套，delete []与new []配套。

#### 21.ifndef/define/endif、program once区别?

​	相同点：作用都是 **防止头文件被重复包含**
​	不同点：
​		1.ifndef 由语言本身提供支持，program once 由编译器提供支持（老编译器可能不支持）；
​		2.运行速度上 ifndef 慢于 program once，倾向于使用 program once；
​		3.ifndef 针对【被define 和 endif 包含的】代码，program once 针对包含该语句的文件；
​		4.若 ifndef 包含的宏定义有名字重复冲突时可能会出现宏未定义bug，而 program once 不存在宏定义冲突。

#### 22.实现strlen()、strstr()功能的函数?

    //返回字符串长度
    int strlen(char*str){
    	for(int i=0;str[i]!=’\0’;i++);
    	return i;
    }
    //判断字符串sub是否是str的子串：如果是则返回sub在str中的首地址，否则返回NULL
    char *strstr(char *str, const char *sub){
    	char *p;
    	for(int i=0;i<strlen(str);i++){
    		p=&str[i];
    		q=sub;
    		if(*p==*q){
    			p++;
    			q++;
    			if(*q==’\0’)
    				return &str[i];
    		}
    	}
    	return null;
    }

#### 23.bool、int、float、指针：与零值比较

​	BOOL：if(a)，if (!a)
​	int：if(a == 0)
​	**float**：
​		const EXPRESSION EXP = 0.000001
​		if(a < EXP && a >-EXP)
​	pointer：if(a != NULL)，if(a == NULL)



#### 24.memset、memcpy、strcpy的区别？

​	1.memset 对一段内存空间全部设为某字符，一般用于已字符串的重初始化；
​	2.memcpy 内存拷贝，可以拷贝任何类型数据，可指定拷贝的数据长度；
​	3.strcpy 只能拷贝字符串，遇到’\0’就结束拷贝。

#### 25.构造函数、析构函数？

**构造函数**：
	1.函数名必须与类名相同；
	2.可以有任意类型的参数，没有返回类型和返回值；
	3.编译系统在定义对象时自动调用构造函数；
	4.可以定义在类内和类外；
	5.是公有函数（public）但不能被显式调用；
	6.不能是virtual（虚函数）。
	=》执行顺序：父类的构造函数==》成员变量构造函数==》类自身的构造函数

**析构函数**：
	1.函数名必须与类名相同，前面加一个波浪号  ~  ；
	2.没有参数，没有返回值，不能被重载，权限控制对其无效，一个类只能有一个析构函数；
	3.编译系统在销毁对象时自动调用析构函数，不能显式调用；
	4.可以是virtual（虚函数）。
	=》执行顺序：

#### 26.虚函数、纯虚函数？

​	1.父类函数中的虚函数，被子类覆盖（重写），通过父类指针调用，有覆盖则调用（子类的）覆盖函数，没有覆盖则调用父类中的函数，从而实现灵活扩展和多态性；
​	2.纯虚函数，必须被子类覆盖，若子类没有覆盖则子类也是抽象类；
​	3.含纯虚函数的类为抽象类，不能被实例化，用作接口类。

**虚/非虚·析构函数**：
	1.析构函数自底向上调用：最先调用最底层派生类（子类）的析构函数，然后调用基类的析构函数；
	2.“部分析构”现象：若派生类（子类）对象通过一个有**非虚析构函数**的基类（父类）指针删除，会导致派生类（子类）不能被销毁而基类（父类）部分被销毁，造成内存泄漏；
	3.基类（父类）定义了**虚析构函数**时，删除派生类（子类）对象将销毁整个对象（包括父类和子类部分）。

#### 27.拷贝（复制）构造函数？

​	拷贝构造函数：可用一个已知对象初始化另一个同类对象。也是类的构造函数，与类名相同，只有一个参数是该类对象的引用，每个类必须有一个拷贝构造函数（没有编写时编译器会自动生成）。
​	会被自动调用三种情况：
​		1.当用类的一个对象去初始化该类的另一个对象时；
​		2.函数形参是类的对象，调用函数进行形参和实参结合时；
​		3.函数返回值是类对象，函数调用完成返回时。

**深拷贝、浅拷贝：**深拷贝，拷贝后对象的逻辑状态相同；浅拷贝，拷贝后对象的物理状态相同；
	1.拷贝构造函数  常规情况下为  浅拷贝；
	2.当有成员指代了系统资源（如动态内存空间）时需要深拷贝，其定义的拷贝构造函数一定是深拷贝的构造函数。

#### 28.类型转换构造函数？

​	是自动调用**类型匹配**的构造函数，自动将基本数据类型转换成对象。

#### 29.成员函数、友元函数的区别？【--友元--】

​	1.成员函数，类定义的一部分，可以直接访问类的成员变量，可通过实例对象调用；
​	2.友元函数，不是类的组成部分，不能直接访问类成员，函数参数需要用成员操作符传递实参。

#### 30.内联函数inline 与 宏#define？【--宏--】

​	1.内联函数：将很简单的函数体**内嵌**到调用它的程序代码中，目的是节约函数调用时的时空开销；
​		函数体必须十分简单，不能含有循环、条件、选择等复杂结构；
​	2.内联函数和宏，区别：
​		宏，由预处理器对宏进行替代；内联函数，是通过编译器控制来实现内嵌
​		内联函数是真正的函数体，在被调用的时候展开（内联函数像宏一样），取消了函数的参数压栈，减少了调用的开销。可以像调用函数一样调用内联函数，而不必担心会产生处理宏的一些问题。
​	3.任何在类的说明部分定义的函数被自动认为是内联函数，内联函数必须和函数体声明在一起。

#### 31.STL标准模板库常用类？

​	向量(vector)：连续存储的元素<vector>
​	列表(list)：由节点组成的双向链表<list>
​	集合(set)：由节点组成的集合<set>
​	栈(stack)：后进先出的值的排列<stack>
​	队列(queue)：先进先出的值的排列<queue>
​	映射(map)：由{键，值}对组成的集合<map>

#### 32.explicit关键字？【？】

​	explicit修饰的构造函数一起使用，显示地类型转换，防止类构造函数执行时对实参数据类型的隐式自动转换。

#### 33.restrict 关键字？

​	restrict 修饰的指针，是能够访问所指区域的唯一入口，目的是限制多个指针指向同一地址。

#### 34.C++的namespace是什么？

​	namespace，命名空间，是C++的语言特性，类似于Java中的包。

#### 35.C++ 异常处理？

一个典型的C++异常**处理流程**：
	1.程序执行时发生错误；
	2.以一个异常对象(如一个整数)记录错误的原因及相关信息；
	3.程序监测到这个错误(读取异常对象)；
	4.程序决定如何处理错误；
	5.进行错误处理，之后恢复/终止程序的执行。

#### 36.可重入/不可重入函数？

​	**可重入函数**：可由多个任务并发使用，可在任意时刻中断，而不必担心数据错误或丢失；
​		1.不可连续的调用持有静态数据；2.不返回静态数据的指针，所有数据都由调用者提供；3.使用本地数据，或者制作全局数据的本地拷贝来保护全局数据；4.必须访问全局变量时利用互斥信号量来保护全局变量；5.绝不调用任何不可重入函数。

​	**不可重入函数**：不能由多个任务共享，除非能确保函数的互斥。
​		1.使用了静态变量；2.函数返回静态变量；3.函数体内调用了不可重入函数；4.函数体内使用了静态变量；5.函数体内调用了malloc()/free()函数；6.函数体内调用了其他标准I/O函数；



------

#### -----------------Python-----------------

重点：装饰器、多线程、numpy、pandas

#### 1.Python 特点和优点?

​	高级语言，解释型语言（C/C++为编译性语言），跨平台，面向过程 + 面向对象，丰富的库，可拓展性
​	缺点：运行速度慢，源代码加密困难

#### 2.list列表、tuple元祖、dict字典、set集合的区别？

​	相同：都是可以包含任意类型的元素的容器；

|       列表 List        |       元祖 tuple        |         字典 dict          |           集合 set           |
| :--------------------: | :---------------------: | :------------------------: | :--------------------------: |
| 创建：list()函数、[,,] | 创建：tuple()函数、(,,) |  创建：dict([])函数、{,,}  |    创建：set()函数、{,,}     |
|   不需要元素类型相同   |   不需要元素类型相同    | 元素由key-键和value-值组成 |       与dict相比少了键       |
| 可使用索引访问，可切片 | 可使用索引访问，可切片  |    键必须唯一，值则不必    |      不可索引，不可切片      |
|     元素值可以修改     | 元素值一旦创建不可修改  |     使用key-键访问元素     | 不可有重复元素【**可去重**】 |

#### 3.list去重方法？

​	1.set()法；2.not in法；

#### 4.python 字典按value排序?	

```
d = {'a': 1, 'b': 4, 'c': 2, 'f' : 12}
sorted(d.items(), key=lambda x: x[1], reverse=True)
# lambda表达式（匿名函数）法
# key=排序目标，x指代第一个参数，x[1]表示排序目标的数值访问，reverse是否逆序（默认false小-大，true大-小）
```

#### 5.**args、\*\*kwargs的区别?

​	在函数参数定义中：
​		\*\*args允许函数传入不定量个数的**非关键字参数**，函数中当做容纳了多个变量的 list 对象
​		\*\*kwargs允许函数传入不定量个数的**关键字参数**，函数中当做容纳了多个变量的 dict 对象

#### 6.pass的用法？

​	空语句（占位语句），不作任何事情，为了保持程序结构完整性

#### 7.yield的用法？

​	调用含yield的函数会返回一个 generator（生成器），当迭代调用过程中执行到 yield 语句时执行返回值并中断当前函数执行，直到下一次迭代时从 yield 的下一行代码继续执行。

#### 8.迭代器和生成器?

​	迭代器 iterator，一个类的迭代器需要实现两个基本方法：
​		1.\_\_iter\_\_（），返回类的 迭代器对象；
​		2.\_\_next\_\_（），返回迭代器的下一个元素；
​	生成器 generator，两种获取方式：
​		1.把一个列表生成式的中括号 [] 改为小括号 ()；
​		2.在函数中使用 **yield关键字** ：调用函数返回一个生成器对象，后续通过调用next()函数对生成器对象进行迭代，执行到yield语句时获取一个返回值并中断当前函数的执行，直到在下一次迭代（调用next()函数）时从yield下一行继续执行。

#### 9.特殊运算符：

​	//、**、and、or、not、成员运算符：in，not in、~（位取反）

#### 10.is、==的区别?

​	Python中对象的三个基本要素：id(身份标识-相当于地址) 、type(数据类型)、value(值)
​		‘ == ’ 比较的是value值（值是不是相等）
​		‘ is ’ 比较的是id（是不是指向同一个地址）

#### 11.range、xrange的区别？

​	range([start]，stop]，step])：根据start与stop指定的范围，step指定步长，生成一个list。
​	xrange：用法与range完全相同，但不是生成list，而是生成器。
​	python 3.x中用range函数；Python2.x 中用xrange函数，用法相同

#### 12.\_\_new\_\_和\_\_init\_\_的区别？

​	\_\_new\_\_：创建对象时调用，返回当前对象的一个实例
​	\_\_init\_\_：创建对象后调用，对当前对象的实例进行初始化
​	调用顺序：先调用\_\_new\_\_生成实例，再调用\_\_init\_\_进行初始化。

#### 13.lambda的用法？

```
# 定义匿名函数
f = lambda x,y:x+y # 求两数之和；x,y是参数，x+y是返回值
```

#### 14.py装饰器？

​	函数装饰器：@classmethod、@staticmethod、@property
​	装饰器，本质是一个Python函数，可以使被修饰函数增加额外功能，装饰器返回值是一个函数对象；
​	功能类型：1.引入日志；2.函数执行时间统计；3.执行函数前预处理；4.执行函数后清理功能；5.权限校验；6.缓存

#### 15.try except用法？

```
try:
	pass  # 异常捕获部分
except Exception as e:  # except可以有0-n个，从上到下根据异常类型匹配，在匹配的Exception中处理异常
	print(e)  # 若发生异常执时行的 异常处理部分
finally:
	pass  # 无论是否发生异常都要执行的 最终执行部分
```

#### 16.py方法解析顺序？

​	方法解析顺序，Method Resolution Order，MRO
​	python 类的 \_\_mro\_\_ 属性值是一个方法解析顺序的tuple元祖，越靠前的越优先解析
​		1.实例本身(instance) ；2.类(class) ；3.父类“列表”（super class）

#### 17.GIL与python程序运行机制？

​	GIL，全局解释器锁(global interpreter lock)，不是python语言的特性，而是python默认解析器Cpython的特性，Cpython要求每个线程必须先获取GIL锁才能执行线程中的代码。
​	目的：解决多线程竞争解析器程序的全局变量而出现的线程安全问题；
​	不足：在多线程中不能充分利用多核cpu资源。因为一个进程只有一把gil锁，进程内的多个线程会争抢gil锁，没有抢到锁的线程会等待cpu；
​	如何解决GIL问题：1.在处理多线程代码时用c或java；2.换解析器，如jpython；3. 多进程+多协程方法；
​	线程释放GIL锁的情况：
​            1.遇到 IO（<u>或其他可能引起阻塞的system call操作</u>）阻塞时会自动释放GIL锁
​            2.Python 3x使用计时器，线程的执行时间达到阈值后释放GIL锁

#### 18.提高python运行效率的方法？

​	根本原因：解释器Cpython运行效率慢
​	提高运行效率的方法：
​		1.核心模块用面向底层的功能包：Cython、PyPy、Pylnline
​		2.尽量使用生成器，节约内存空间
​		3.循环代码优化：避免重复或复杂的操作、列表推导式
​		4.多进程、多线程、协程
​		5.多个if分支判断时，将最有可能发生的条件放到最前面（减少判断次数，提高效率）

#### 19.Python 如何实现多线程和多进程？

​	**多线程**：1.threading.Thread 模块，重写run方法；2.concurrent.futures.ThreadPoolExecutor 线程池模块；3._thread.start_new_thread。

​	**多进程**：1.multiprocessing.Process 模块，传入任务执行函数或重写run方法；2.os.fork() 只在Unix系统有效，执行一次返回两次（子进程id和0）；4.使用进程池Pool。

#### 20.Python 程序退出时内存释放情况？

​	程序退出时不会立即释放的内存：1.循环引用的其他对象；2.引用自全局命名空间的对象；3.c库保留的内存部分。

#### 21.Python 中如何管理内存?

​	**引用计数**：Python使用引用计数来<u>追踪内存中的对象有多少个引用</u>。在对象被创建时创建引用计数，在对象不被需要且引用计数为0时被垃圾回收。
​	引用计数+1：对象的创建；对象别名的创建；作为参数传递给函数；作为容器的一个元素。
​	引用计数-1：引用离开了作用域；对象别名被销毁；对象别名被重新初始化；被容器移除；容器被销毁。

​	**垃圾回收**：<u>垃圾收集器</u>会清理掉不再使用的内存（如引用计数为0的对象）；<u>循环垃圾回收器</u>确保循环引用对象的释放（如，a引用b，b引用a时引用计数永远不为0）。

​	**内存池机制**：<u>用于管理小块内存的申请和释放</u>。Python中许多时候是小块内存的申请和释放，会大量执行malloc/free操作，频繁地在用户态和核心态之间切换将严重影响Python执行效率。

​	·Python垃圾**回收的内存放回内存池**，而不是返回给操作系统。
​	·Python小于256个字节的对象用 **pymalloc 分配**，而大的对象用系统 malloc 分配。
​	·Python整数，浮点数，List 对象都有**独立的私有内存池**，不同类对象间不会共享内存。

#### 22.python随机种子seed？

​	np.random.**seed( )** 随机数生成的法则与设置的seed值有关：
​		1.设置相同的seed( )值生成的随机数相同； 
​		2.不设置seed( )值时系统根据时间自动选择seed值，此时随机数生成因时间差异而不同；

```
import random
random.seed( 10 )
print(random.random())  # 0.5714025946899135
random.seed( 10 )  # 生成同一个随机数
print(random.random())  # 0.5714025946899135
```

#### 23.list，numpy-array，torch-tensor，Variable

**list 与 numpy array 的区别**：
	list 元素数据类型不必相同，可以方便地增删修改元素，在通用性和灵活性上优于array；
	array 元素数据类型必须相同，使用连续的内存块，可高效地实现矩阵运算，有优越的存储效率和计算性能；

|        | list                    | array               | tensor                    |
| ------ | ----------------------- | ------------------- | ------------------------- |
| list   | **[,,,]**               | np.array(list)      | torch.Tensor(list)        |
| array  | ndarray.tolist()        | **np.array([,,,])** | torch.from_numpy(ndarray) |
| tensor | tensor.numpy().tolist() | tensor.numpy()      | **torch.tensor([,,,])**   |

**Variable** 与 矩阵/张量、常量？
	Variable 变量，是为了自动求导对 Tensor 的进一步封装，在计算时生成计算图将所有计算节点连接起来，在进行梯度反向传播的时候可以一次性将所有梯度都计算出来。Variable 与 array、tensor 之间的转换：

| Variable       | array                               | tensor           |
| -------------- | ----------------------------------- | ---------------- |
| ===》 Variable | Variable(torch.from_numpy(ndarray)) | Variable(tensor) |
| Variable===》  | variable.data.numpy()               | variable.data    |



#### -------------------常问-------------------

#### 1.常用设计模式？

​	共有23种设计模式，在c++开发中常用有15种：
​	**工厂模式**；策略模式；**单例模式**；迭代器模式；抽象工厂模式；建造者模式；适配器模式；桥接模式；组合模式；解释器模式；命令模式；中介者模式；观察者模式；状态模式；代理模式；

#### 2.单例模式的C++实现？

​	**单例模式**：保证一个类仅有一个实例，并提供一个全局访问点，且该实例被所有程序模块共享。

​	由于构造函数私有，无法通过构造函数实例化，需要通过调用静态函数GetInstance获取实例

```
//Singleton.h
class Singleton{
public:
	static Singleton* GetInstance();//静态的获取实例方法
private:
	Singleton() {}//构造函数被私有化
	static Singleton *singleton;
};

//Singleton.cpp
Singleton* Singleton::singleton = NULL;//创建一个null对象
Singleton* Singleton::GetInstance(){//调用 获取实例方法
	if(singleton == NULL){//如果实例为空，则创建一个实例；不为空则直接返回该实例。
		singleton = new Singleton();
	}
	return singleton;//返回该静态实例
}
```



#### 3.面向对象三大特性？

​	封装、继承、多态。
​	**封装：**是对象和类的主要特性，把客观事物的<u>属性和功能封装</u>起来，通过public、protected、private关键字控制外部对象的访问权限，实现信息隐藏。
​	**继承：**1.通过继承可以使用现有类的所有功能，在无须重新定义类的情况下对<u>现有类进行功能扩展</u>；（子类拓展父类功能）；2.一个子类只继承一个父类，可以多级继承而不要多重继承（某些OOP语言可以多重继承）；
​	**多态：**1.允许将父类对象定义为子类类型（子类类型的指针赋值给父类型的指针）；2.多态的两种实现方式：
​		**覆盖**：子类重新定义父类的虚函数；**重载**：允许存在多个同名但参数列表不同的函数；

#### 4.类与对象区别？

​	类与对象的区别：一般与个体、抽象与具体、集体与个体。

#### 5.接口和抽象类区别？

​	c++中没有接口的概念，与之对应的是纯虚类，即只含有纯虚函数的类，c++抽象类是含有纯虚成员函数的类。
​	1.不能实例化；
​	2.包含未实现的方法声明；
​	3.派生类必须实现方法，抽象类是抽象方法，接口是所有成员（变量和方法）；

#### 6.进程和线程区别？

​	线程是进程内的一个可执行单元、可调度实体。
​	**调度**：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位；
​	**并发性**：进程之间可以并发，进程内线程也可以并发；
​	**资源**：进程是拥有资源的独立单元，线程时可以访问进程的资源的执行单位；
​	**开销**：在系统开销方面，对进程的创建与撤销   大于   对线程创建与撤销

多线程与多进程？
	**进程**是系统进行资源分配和调度的一个独立单位。**线程**是CPU调度和分派的基本单位。
	一个程序至少有一个进程，一个进程至少有一个线程，线程必须依存在进程中才能执行（不能独立运行）；
	多进程各自独享内存，多线程之间共享进程的内存；线程自己只拥有基本运行资源（如程序计数器，寄存器，栈）
	多线程执行开销小，但不利于系统资源的管理和保护；多进程运行开销大，但可以管理和保护好系统资源。

#### 7.内存分配方式有哪些？

​	1.从**静态存储区域**分配。如全局变量，static 变量在程序编译的时候就分配好，在程序的整个运行期间都存在。
​	2.在**栈**上创建。如函数内局部变量 在函数执行时在栈上创建存储单元，执行结束后存储单元自动释放。
​	3.从**堆**上分配，动态内存分配。生存周期由程序员灵活使用，malloc/new 申请内存，free/delete 释放内存。

#### 8.内存泄漏、数组越界怎么办？怎么避免？

​	内存泄露：用动态内存分配函数开辟的内存空间，在使用完毕后未释放导致一直占据该内存单元。
​	避免方案：
​		1.使用时记住指针长度；
​		2.malloc时确定free位置；
​		3.对指针赋值时注意被赋值指针需要不需要释放；
​		4.动态分配内存的指针尽量不要重赋值.
​		5.优先考虑使用智能指针.